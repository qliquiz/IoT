# Реализация многозадачного управления светодиодами с использованием прерываний таймера на микроконтроллере ATmega328P

## 1. Введение и постановка задачи

### 1.1. Цель проекта

Целью данного проекта является разработка программы для асинхронного управления пятью отдельными светодиодами,
каждый из которых должен мигать с уникальной, заранее определённой частотой. Программная реализация должна выполняться на микроконтроллере
ATmega328P (платформа Arduino UNO) с соблюдением строгих ограничений: отказ от использования блокирующих функций (`delay()`), прямое манипулирование
регистрами портов ввода-вывода и применение одного аппаратного таймера для управления всеми светодиодами.

### 1.2. Проблема блокирующих задержек

Стандартный подход к созданию временных пауз с использованием функции `delay()` является блокирующим. Это означает, что
во время выполнения этой функции микроконтроллер полностью приостанавливает основную программу, что делает невозможным
одновременное выполнение других задач, таких как опрос датчиков, обработка команд или управление другими устройствами.

### 1.3. Предложенное решение

Для реализации неблокирующей многозадачности применяется механизм аппаратных прерываний, генерируемых встроенным таймером
микроконтроллера. Таймер настраивается на создание периодического прерывания с фиксированным временным интервалом. Этот
интервал служит базовой единицей времени («тиком») для всей системы. Глобальный счётчик тиков инкрементируется в обработчике
прерывания (ISR), а состояние каждого светодиода изменяется тогда, когда счётчик становится кратным периоду мигания, назначенному этому светодиоду.

## 2. Аппаратная часть

### 2.1. Список компонентов

*   Микроконтроллер: Arduino UNO (на базе ATmega328P).
*   5 светодиодов (любого цвета).
*   5 токоограничивающих резисторов номиналом 220 Ом.
*   Макетная плата и соединительные провода.

### 2.2. Схема подключения

Светодиоды подключаются к цифровым выводам, относящимся к порту `PORTB`, для обеспечения возможности одновременного управления через регистры.

| Компонент | Пин Arduino | Регистр и бит |
| :-------- | :---------: | :-----------: |
| Светодиод 1 |      8      |      PB0      |
| Светодиод 2 |      9      |      PB1      |
| Светодиод 3 |      10     |      PB2      |
| Светодиод 4 |      12     |      PB4      |
| Светодиод 5 |      13     |      PB5      |

## 3. Программная реализация

### 3.1. Настройка таймера (Timer1)

Для генерации точных временных интервалов используется 16-битный **Таймер1** в режиме **CTC** (Clear Timer on Compare).

*   **Тактовая частота (F_CPU):** 16 МГц.
*   **Предделитель (Prescaler):** 64. Понижает частоту таймера до `16,000,000 / 64 = 250,000` Гц.
*   **Частота прерываний:** 25 Гц (базовый интервал — **40 мс**).
*   **Значение регистра сравнения (`OCR1A`):**
    `OCR1A = (F_CPU / Prescaler) / Frequency - 1 = (250,000 / 25) - 1 = 10,000 - 1 = 9999`

Данная конфигурация вызывает прерывание `TIMER1_COMPA_vect` каждые 40 миллисекунд.

### 3.2. Управление портами через регистры

Для максимальной производительности настройка и управление пинами производятся напрямую через регистры микроконтроллера.

*   **`DDRB` (Data Direction Register Port B):** Регистр направления данных порта B. Установка бита в `1` конфигурирует соответствующий пин как выход.
*   **`PORTB` (Data Register Port B):** Регистр данных порта B. При настройке пина как выхода, запись в соответствующий бит этого регистра управляет его логическим уровнем. Инвертирование состояния бита осуществляется побитовой операцией XOR (`^=`).

### 3.3. Исходный код

Ниже представлен финальный код, который реализует поставленную задачу с базовым интервалом 40 мс. Для повышения читаемости и масштабируемости параметры светодиодов хранятся в массивах.

```cpp
#include <avr/io.h>
#include <avr/interrupt.h>

// Массивы, определяющие пины и периоды для каждого из светодиодов.
const uint8_t led_pins[] = {PB0, PB1, PB2, PB4, PB5}; // Пины D8, D9, D10, D12, D13

// Период теперь задается в "тиках" по 40 мс.
// Например, период 10 означает, что светодиод переключается каждые 10 * 40 мс = 400 мс.
const int led_periods[] = {10, 20, 30, 40, 50};
const int NUM_LEDS = 5;

// Глобальный счётчик прерываний. Ключевое слово 'volatile' гарантирует,
// что компилятор будет обращаться к переменной напрямую из памяти,
// что критически важно для переменных, изменяемых в ISR.
volatile unsigned long timer_ticks = 0;

void setup() {
  // Формирование битовой маски для настройки всех пинов одновременно
  uint8_t pin_mask = 0;
  for (int i = 0; i < NUM_LEDS; i++) {
    pin_mask |= (1 << led_pins[i]);
  }

  // Настройка пинов порта B как выходов
  DDRB |= pin_mask;
  // Установка начального состояния светодиодов (выключено)
  PORTB &= ~pin_mask;

  // Глобальное отключение прерываний на время настройки таймера
  cli();

  // Инициализация управляющих регистров Таймера1
  TCCR1A = 0;
  TCCR1B = 0;
  
  // Установка режима CTC (сброс по совпадению)
  TCCR1B |= (1 << WGM12);
  // Установка предделителя на 64
  TCCR1B |= (1 << CS11) | (1 << CS10);
  
  // Запись рассчитанного значения в регистр сравнения для интервала в 40 мс
  OCR1A = 9999;
  
  // Разрешение прерывания по совпадению с регистром OCR1A
  TIMSK1 |= (1 << OCIE1A);

  // Глобальное разрешение прерываний
  sei();
}

// Обработчик прерывания ISR (Interrupt Service Routine) для Таймера1
// Этот код выполняется автоматически каждые 40 мс
ISR(TIMER1_COMPA_vect) {
  // Инкремент счётчика тиков
  timer_ticks++;

  // Цикл проверки и переключения состояния каждого светодиода
  for (int i = 0; i < NUM_LEDS; i++) {
    if (timer_ticks % led_periods[i] == 0) {
      // Инвертирование состояния пина с помощью операции XOR
      PORTB ^= (1 << led_pins[i]);
    }
  }
}

// Основной цикл программы
void loop() {
  // Основной цикл свободен, так как вся логика выполняется асинхронно
  // в обработчике прерывания.
}
```

## 4. Результаты и верификация

### 4.1. Симуляция в Tinkercad

Корректность работы схемы и программного кода была проверена с помощью онлайн-симулятора Tinkercad.

**[Ссылка для доступа к симуляции](https://www.tinkercad.com/things/gaqz72hGVBr-spectacular-stantia?sharecode=iSeVhC9CxPTndtZeDG8e9y1_D2MCjWfKWenjLb59otw)**

### 4.2. Видеодемонстрация

В качестве финального подтверждения работоспособности прилагается видеозапись работы схемы на физической плате Arduino UNO.

<video width="320" height="240" controls>
  <source src="setup.mp4" type="video/mp4">
</video>

## 5. Заключение

Данный проект успешно демонстрирует применение низкоуровневых механизмов микроконтроллера
ATmega328p — таймеров и прерываний — для создания эффективной, неблокирующей программы. Использование
прямого доступа к регистрам обеспечивает максимальную производительность. Представленный подход является
основополагающим для разработки встраиваемых систем, требующих выполнения нескольких задач в режиме реального времени.
Главный цикл `loop()` остается свободным, что позволяет расширять функциональность проекта без ущерба для точности выполнения временных задач.